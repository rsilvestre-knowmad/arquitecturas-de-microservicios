# 4.2 ‚Äì Event Sourcing

---

## üéØ Objetivo

Comprender el patr√≥n **Event Sourcing**, su relaci√≥n con CQRS y c√≥mo permite reconstruir el estado de un sistema a partir de **eventos hist√≥ricos**.
Veremos su prop√≥sito, ventajas, funcionamiento y un ejemplo funcional en Node.js.

---

## üß© Contexto

En el modelo tradicional, cada actualizaci√≥n de un recurso **sobrescribe** su valor en la base de datos.

Por ejemplo:

| Acci√≥n                       | Estado almacenado |
| ---------------------------- | ----------------- |
| Crear pedido (total 50)      | `{ total: 50 }`   |
| Actualizar pedido (total 60) | `{ total: 60 }`   |

El valor anterior se pierde, no hay historia del cambio.
Esto dificulta auditor√≠as, rollbacks o reproducciones del sistema.

---

## ‚öôÔ∏è Qu√© propone Event Sourcing

> En lugar de guardar solo el **estado actual**, se guarda la **secuencia de eventos** que llevaron a ese estado.

Cada cambio de estado se representa como un **evento inmutable**, y el estado actual se **reconstruye** reproduciendo esos eventos.

```text
pedido_creado ‚Üí pago_confirmado ‚Üí pedido_enviado ‚Üí pedido_entregado
```

---

## üß≠ Flujo b√°sico de Event Sourcing

```mermaid
sequenceDiagram
  participant API as Cliente / API
  participant CMD as Command Service
  participant ES as Event Store
  participant QRY as Query Service
  participant VIEW as Read Model

  API->>CMD: POST /pedido
  CMD-->>ES: Guarda evento "pedido_creado"
  CMD-->>QRY: Publica evento
  QRY-->>VIEW: Actualiza vista de lectura
  API->>QRY: GET /pedidos
  QRY-->>API: Devuelve vista reconstruida
```

üü¶ **Command Service**: genera y persiste los eventos.
üüß **Event Store**: almac√©n inmutable de eventos.
üü© **Query Service**: reconstruye la vista de lectura procesando los eventos.

---

## üß± Diferencia entre CQRS y Event Sourcing

| Concepto        | CQRS                                    | Event Sourcing                                        |
| --------------- | --------------------------------------- | ----------------------------------------------------- |
| Prop√≥sito       | Separar lectura y escritura             | Persistir todos los cambios como eventos              |
| Enfoque         | Procesos de negocio                     | Persistencia de estado                                |
| Resultado final | Modelo de lectura actualizado           | Log hist√≥rico completo                                |
| Relaci√≥n        | CQRS usa eventos para comunicar cambios | Event Sourcing es la fuente de verdad de esos eventos |

Ambos patrones suelen aplicarse juntos:

* CQRS ‚Üí organiza las responsabilidades.
* Event Sourcing ‚Üí registra cada cambio de forma inmutable.

---

## üì¶ Estructura t√≠pica de eventos

Cada evento suele tener la forma:

```json
{
  "id": "evt-1730780000123",
  "tipo": "pedido_creado",
  "timestamp": "2025-11-04T10:12:00Z",
  "data": {
    "pedidoId": 101,
    "cliente": "Ana",
    "total": 120.5
  }
}
```

---

## üß© Ejemplo funcional ‚Äì Node.js

A continuaci√≥n, un ejemplo sencillo que muestra c√≥mo guardar eventos y reconstruir el estado de un pedido desde ellos.

### üóÉÔ∏è events-store.js

Simula un almac√©n de eventos en memoria:

```js
// events-store.js
export const eventStore = [];

export function saveEvent(evento) {
  eventStore.push(evento);
  console.log("üíæ Evento guardado:", evento.tipo);
}

export function getEventsByPedido(id) {
  return eventStore.filter(e => e.data.pedidoId === id);
}
```

---

### üß† reconstruct.js

Reconstruye el estado actual de un pedido reproduciendo los eventos:

```js
// reconstruct.js
import { getEventsByPedido } from "./events-store.js";

export function reconstruirPedido(pedidoId) {
  const eventos = getEventsByPedido(pedidoId);
  const estado = { id: pedidoId, estado: "DESCONOCIDO", total: 0 };

  for (const ev of eventos) {
    switch (ev.tipo) {
      case "pedido_creado":
        estado.estado = "CREADO";
        estado.total = ev.data.total;
        break;
      case "pago_confirmado":
        estado.estado = "PAGADO";
        break;
      case "pedido_enviado":
        estado.estado = "ENVIADO";
        break;
      case "pedido_entregado":
        estado.estado = "ENTREGADO";
        break;
    }
  }
  return estado;
}
```

---

### ‚öôÔ∏è commands-service.js

```js
// commands-service.js
import express from "express";
import { saveEvent } from "./events-store.js";

const app = express();
app.use(express.json());

app.post("/pedido", (req, res) => {
  const evento = {
    id: "evt-" + Date.now(),
    tipo: "pedido_creado",
    timestamp: new Date().toISOString(),
    data: { pedidoId: Date.now(), cliente: req.body.cliente, total: req.body.total }
  };
  saveEvent(evento);
  res.json({ status: "ok", evento });
});

app.post("/pedido/:id/pago", (req, res) => {
  const evento = {
    id: "evt-" + Date.now(),
    tipo: "pago_confirmado",
    timestamp: new Date().toISOString(),
    data: { pedidoId: parseInt(req.params.id) }
  };
  saveEvent(evento);
  res.json({ status: "ok", evento });
});

app.listen(4000, () => console.log("üü¶ Commands Service en puerto 4000"));
```

---

### üìÑ queries-service.js

```js
// queries-service.js
import express from "express";
import { reconstruirPedido } from "./reconstruct.js";

const app = express();

app.get("/pedido/:id", (req, res) => {
  const estado = reconstruirPedido(parseInt(req.params.id));
  res.json(estado);
});

app.listen(4001, () => console.log("üüß Queries Service en puerto 4001"));
```

---

### üß™ Prueba interactiva

```bash
# Crear pedido
curl -X POST http://localhost:4000/pedido \
  -H "Content-Type: application/json" \
  -d '{"cliente": "Ana", "total": 120.5}'

# Confirmar pago
curl -X POST http://localhost:4000/pedido/1730780/pago

# Consultar estado actual
curl http://localhost:4001/pedido/1730780
```

üìú El sistema reconstruye el estado final leyendo los eventos guardados.

---

## üîÅ Flujo de reconstrucci√≥n visual

```mermaid
sequenceDiagram
  participant Store as Event Store
  participant Rebuilder as Reconstrucci√≥n
  participant Client as Cliente

  Note over Store: Historial de eventos
  Store->>Rebuilder: pedido_creado
  Store->>Rebuilder: pago_confirmado
  Store->>Rebuilder: pedido_enviado
  Store->>Rebuilder: pedido_entregado
  Rebuilder->>Client: Estado final = ENTREGADO
```

---

## üß† Ventajas de Event Sourcing

| Ventaja                          | Descripci√≥n                                                |
| -------------------------------- | ---------------------------------------------------------- |
| **Auditor√≠a completa**           | Permite ver el historial exacto de lo ocurrido.            |
| **Reproducibilidad**             | Puedes reconstruir cualquier estado pasado.                |
| **Integraci√≥n natural con CQRS** | Los eventos alimentan el modelo de lectura.                |
| **Escalabilidad**                | Los servicios pueden suscribirse a los eventos relevantes. |

---

## ‚ö†Ô∏è Desaf√≠os comunes

| Reto                   | Soluci√≥n habitual                                  |
| ---------------------- | -------------------------------------------------- |
| Tama√±o del historial   | Implementar *snapshots* peri√≥dicos.                |
| Migraciones de esquema | Versionar los tipos de evento.                     |
| Complejidad inicial    | Automatizar el almacenamiento y replay de eventos. |

---

## üí¨ Analog√≠a docente

> Imagina que una base de datos tradicional es una **fotograf√≠a** del momento actual,
> mientras que Event Sourcing es **una pel√≠cula completa**: puedes ver c√≥mo llegaste a ese estado, avanzar o retroceder en el tiempo.

---

## üîö Conclusi√≥n

El patr√≥n **Event Sourcing** aporta:

* Trazabilidad total.
* Reconstrucci√≥n del estado hist√≥rico.
* Integraci√≥n fluida con CQRS.

En el siguiente apartado (4.3) llevaremos esto a la pr√°ctica en un laboratorio real con **Event Store + CQRS funcional en Node.js y RabbitMQ**, donde se observar√° la persistencia y reconstrucci√≥n de eventos en tiempo real.