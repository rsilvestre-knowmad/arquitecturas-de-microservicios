# 4.3 â€“ ðŸ§ª Laboratorio: CQRS y Event Sourcing

---

## ðŸŽ¯ Objetivos

* Aplicar de forma prÃ¡ctica los conceptos de **CQRS** y **Event Sourcing**.
* Observar cÃ³mo los **comandos** generan eventos y cÃ³mo los **servicios de consulta** reconstruyen el estado.
* Comprender el concepto de **consistencia eventual** en entornos distribuidos.
* Ejercitar la depuraciÃ³n y trazabilidad de eventos mediante **RabbitMQ**.

---

## ðŸ§± Estructura del laboratorio

```
LABS/cqrs_event_sourcing/
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ commands-service/
â”‚   â””â”€â”€ index.js
â”œâ”€â”€ queries-service/
â”‚   â””â”€â”€ index.js
â””â”€â”€ events-store/
    â””â”€â”€ store.js
```

---

## ðŸ³ Paso 1 â€” Crear el entorno `docker-compose.yml`

Guarda este archivo como:
`LABS/cqrs_event_sourcing/docker-compose.yml`

```yaml
version: "3.9"

services:
  rabbitmq:
    image: rabbitmq:3-management
    container_name: rabbitmq
    ports:
      - "5672:5672"
      - "15672:15672"

  commands-service:
    image: node:22
    container_name: commands-service
    working_dir: /app
    volumes:
      - ./commands-service:/app
    command: bash -c "npm install express amqplib && node index.js"
    environment:
      - RABBITMQ_URL=amqp://rabbitmq
    ports:
      - "5000:5000"
    depends_on:
      - rabbitmq

  queries-service:
    image: node:22
    container_name: queries-service
    working_dir: /app
    volumes:
      - ./queries-service:/app
    command: bash -c "npm install express amqplib && node index.js"
    environment:
      - RABBITMQ_URL=amqp://rabbitmq
    ports:
      - "5001:5001"
    depends_on:
      - rabbitmq
```

---

## âš™ï¸ Paso 2 â€” Servicio de Comandos

Guarda este archivo como
`LABS/cqrs_event_sourcing/commands-service/index.js`

```js
import express from "express";
import amqp from "amqplib";

const app = express();
app.use(express.json());
const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://rabbitmq";
const EXCHANGE = "eventos_pedidos";

// FunciÃ³n para publicar un evento
async function publicarEvento(evento) {
  const conn = await amqp.connect(RABBITMQ_URL);
  const ch = await conn.createChannel();
  await ch.assertExchange(EXCHANGE, "fanout", { durable: true });
  ch.publish(EXCHANGE, "", Buffer.from(JSON.stringify(evento)));
  console.log("ðŸ“¤ Evento publicado:", evento.tipo);
  await ch.close();
  await conn.close();
}

// POST /pedido â†’ genera evento "pedido_creado"
app.post("/pedido", async (req, res) => {
  const pedido = {
    id: Date.now(),
    cliente: req.body.cliente,
    total: req.body.total,
    estado: "CREADO"
  };

  const evento = {
    tipo: "pedido_creado",
    timestamp: new Date().toISOString(),
    data: pedido
  };

  await publicarEvento(evento);
  res.json({ status: "ok", evento });
});

app.listen(5000, () => console.log("ðŸŸ¦ Commands Service en puerto 5000"));
```

---

## ðŸŸ§ Paso 3 â€” Servicio de Consultas

Guarda este archivo como
`LABS/cqrs_event_sourcing/queries-service/index.js`

```js
import express from "express";
import amqp from "amqplib";

const app = express();
let pedidos = [];
const RABBITMQ_URL = process.env.RABBITMQ_URL || "amqp://rabbitmq";
const EXCHANGE = "eventos_pedidos";

// Escuchar eventos del bus y mantener vista actualizada
async function escucharEventos() {
  const conn = await amqp.connect(RABBITMQ_URL);
  const ch = await conn.createChannel();
  await ch.assertExchange(EXCHANGE, "fanout", { durable: true });

  const q = await ch.assertQueue("cola_pedidos", { durable: false });
  await ch.bindQueue(q.queue, EXCHANGE, "");

  console.log("ðŸ“¥ Query Service escuchando eventos...");

  ch.consume(q.queue, msg => {
    const evento = JSON.parse(msg.content.toString());
    console.log("ðŸ”„ Evento recibido:", evento.tipo);

    if (evento.tipo === "pedido_creado") {
      pedidos.push(evento.data);
    }

    ch.ack(msg);
  });
}

// Endpoint de lectura
app.get("/pedidos", (req, res) => {
  res.json({ total: pedidos.length, data: pedidos });
});

escucharEventos();
app.listen(5001, () => console.log("ðŸŸ§ Queries Service en puerto 5001"));
```

---

## ðŸ§© Paso 4 â€” SimulaciÃ³n del Event Store

Para simplificar el laboratorio, RabbitMQ actuarÃ¡ como â€œbus de eventosâ€,
pero puedes aÃ±adir una carpeta `events-store/` con un simple archivo local que guarde los eventos en memoria o disco si quieres persistencia:

`LABS/cqrs_event_sourcing/events-store/store.js`

```js
export const events = [];
export function save(evento) {
  events.push(evento);
  console.log("ðŸ’¾ Guardado en Event Store:", evento.tipo);
}
export function all() { return events; }
```

*(Opcional: se puede integrar en el Commands Service si se desea auditar los eventos localmente.)*

---

## ðŸ§ª Paso 5 â€” Pruebas del flujo

1ï¸âƒ£ **Levanta el entorno:**

```bash
docker compose up
```

2ï¸âƒ£ **Crea un pedido (comando):**

```bash
curl -X POST http://localhost:5000/pedido \
  -H "Content-Type: application/json" \
  -d '{"cliente":"David","total":150.5}'
```

3ï¸âƒ£ **Consulta los pedidos (query):**

```bash
curl http://localhost:5001/pedidos
```

âœ… VerÃ¡s algo como:

```json
{
  "total": 1,
  "data": [
    {
      "id": 1730781630001,
      "cliente": "David",
      "total": 150.5,
      "estado": "CREADO"
    }
  ]
}
```

---

## ðŸ§  QuÃ© observar

| Elemento           | FunciÃ³n                                         |
| ------------------ | ----------------------------------------------- |
| `commands-service` | Publica eventos al crear pedidos                |
| `RabbitMQ`         | Distribuye los eventos                          |
| `queries-service`  | Escucha eventos y mantiene su modelo de lectura |
| `GET /pedidos`     | Devuelve el estado reconstruido                 |

---

## ðŸ” Flujo CQRS + Event Sourcing

```mermaid
sequenceDiagram
  participant CMD as Commands Service
  participant BUS as RabbitMQ
  participant QRY as Queries Service

  CMD->>BUS: Evento "pedido_creado"
  BUS-->>QRY: Entrega evento
  QRY-->>QRY: Actualiza modelo de lectura
  QRY->>Cliente: GET /pedidos â†’ vista actualizada
```

---

## ðŸ“Š Comparativa prÃ¡ctica

| Enfoque               | Lectura           | Escritura           | Persistencia             | Consistencia             |
| --------------------- | ----------------- | ------------------- | ------------------------ | ------------------------ |
| MonolÃ­tico            | Mismo modelo      | Mismo modelo        | Base de datos relacional | Inmediata                |
| CQRS                  | Modelos separados | Modelos separados   | Eventos in-memory        | Eventual                 |
| CQRS + Event Sourcing | Modelos separados | Eventos persistidos | Event Store              | Eventual + Auditabilidad |

---

## ðŸ”š ConclusiÃ³n

Con este laboratorio has puesto en prÃ¡ctica:

* El patrÃ³n **CQRS**, separando escritura y lectura.
* El patrÃ³n **Event Sourcing**, persistiendo el flujo de eventos.
* El concepto de **consistencia eventual** entre ambos mundos.
* El uso de **RabbitMQ** como bus de eventos distribuidos.

ðŸŽ¯ Resultado: un sistema distribuido trazable, extensible y resiliente.