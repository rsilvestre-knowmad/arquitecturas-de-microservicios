# 5.2 â€“ Seguridad distribuida en microservicios

---

## ğŸ¯ Objetivo

Comprender cÃ³mo se gestiona la **seguridad en entornos distribuidos**,
donde mÃºltiples microservicios deben autenticarse y autorizar operaciones sin depender de un Ãºnico proceso central.

AprenderÃ¡s:

* QuÃ© significa **autenticaciÃ³n** y **autorizaciÃ³n** en un sistema distribuido.
* CÃ³mo funciona la propagaciÃ³n de identidad con **JWT (JSON Web Tokens)**.
* Patrones de **seguridad interservicios**.
* Buenas prÃ¡cticas para evitar fugas o accesos indebidos.

---

## ğŸ§© Contexto

En una aplicaciÃ³n monolÃ­tica, la autenticaciÃ³n suele ser sencilla:

* un Ãºnico backend,
* una sesiÃ³n por usuario,
* control de acceso centralizado.

En microservicios, cada servicio es independiente, lo que introduce nuevos retos:

* Cada servicio expone endpoints propios.
* El trÃ¡fico puede pasar por un Gateway, balanceadores o colas.
* Es necesario **propagar la identidad del usuario** de forma segura.

---

## âš™ï¸ Conceptos clave

| Concepto                     | DescripciÃ³n                                     |
| ---------------------------- | ----------------------------------------------- |
| **AutenticaciÃ³n (AuthN)**    | Verifica la identidad del usuario o servicio.   |
| **AutorizaciÃ³n (AuthZ)**     | Determina quÃ© puede hacer esa identidad.        |
| **Confidencialidad**         | Los datos viajan cifrados (HTTPS, TLS).         |
| **Integridad**               | Se evita la manipulaciÃ³n de mensajes.           |
| **PropagaciÃ³n de identidad** | CÃ³mo los servicios â€œsabenâ€ quiÃ©n es el usuario. |

---

## ğŸ§­ Esquema bÃ¡sico: seguridad entre servicios

```mermaid
sequenceDiagram
  participant C as Cliente
  participant G as API Gateway
  participant A as Auth Service
  participant O as Orders Service
  participant P as Payments Service

  C->>G: Login (usuario, contraseÃ±a)
  G->>A: Verifica credenciales
  A-->>G: Devuelve token JWT
  G-->>C: Token JWT
  C->>G: Solicitud con token
  G->>O: ReenvÃ­a token en header
  O->>P: Llama a Payments con el mismo token
  P-->>O: Respuesta autorizada
```

ğŸŸ¦ El cliente obtiene un **JWT** firmado.
ğŸŸ§ El token viaja en los headers HTTP.
ğŸŸ© Cada microservicio valida el token antes de procesar la peticiÃ³n.

---

## ğŸ” JSON Web Tokens (JWT)

Un **JWT** es un token firmado digitalmente que contiene la identidad y permisos del usuario.

Formato:

```
header.payload.signature
```

Ejemplo:

```json
{
  "sub": "user123",
  "role": "admin",
  "iat": 1730791200,
  "exp": 1730794800
}
```

---

### ğŸ§© VerificaciÃ³n tÃ­pica de un JWT

1. Se comprueba la **firma** con una clave secreta.
2. Se valida la **fecha de expiraciÃ³n (exp)**.
3. Se usa el **payload** para decisiones de autorizaciÃ³n.

---

## âš™ï¸ Ejemplo funcional â€“ ValidaciÃ³n JWT en Node.js

### ğŸ“„ `auth-service.js`

Servicio de autenticaciÃ³n que genera tokens JWT.

```js
import express from "express";
import jwt from "jsonwebtoken";

const app = express();
app.use(express.json());
const SECRET = "CLAVE_SUPER_SECRETA"; // en prÃ¡ctica â†’ variable de entorno

app.post("/login", (req, res) => {
  const { usuario, password } = req.body;

  if (usuario === "admin" && password === "1234") {
    const token = jwt.sign(
      { sub: usuario, rol: "admin" },
      SECRET,
      { expiresIn: "1h" }
    );
    res.json({ token });
  } else {
    res.status(401).json({ error: "Credenciales invÃ¡lidas" });
  }
});

app.listen(3005, () => console.log("ğŸ” Auth Service en puerto 3005"));
```

---

### ğŸ“„ `orders-service.js`

Servicio protegido que valida el token recibido.

```js
import express from "express";
import jwt from "jsonwebtoken";

const app = express();
const SECRET = "CLAVE_SUPER_SECRETA";

function verificarToken(req, res, next) {
  const header = req.headers.authorization;
  if (!header) return res.status(401).json({ error: "Falta token" });

  const token = header.split(" ")[1];
  try {
    req.usuario = jwt.verify(token, SECRET);
    next();
  } catch (e) {
    res.status(401).json({ error: "Token invÃ¡lido o expirado" });
  }
}

app.get("/pedidos", verificarToken, (req, res) => {
  res.json({ usuario: req.usuario.sub, pedidos: ["A123", "B456"] });
});

app.listen(3006, () => console.log("ğŸ“¦ Orders Service en puerto 3006"));
```

---

### ğŸ§ª Prueba del flujo

```bash
# 1ï¸âƒ£ Solicitar token
curl -X POST http://localhost:3005/login \
  -H "Content-Type: application/json" \
  -d '{"usuario":"admin","password":"1234"}'

# 2ï¸âƒ£ Guardar token devuelto
TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI..."

# 3ï¸âƒ£ Acceder al servicio protegido
curl -H "Authorization: Bearer $TOKEN" http://localhost:3006/pedidos
```

âœ… VerÃ¡s una respuesta autorizada:

```json
{
  "usuario": "admin",
  "pedidos": ["A123", "B456"]
}
```

---

## ğŸ§± Seguridad inter-servicios

AdemÃ¡s de los usuarios humanos, los **microservicios tambiÃ©n deben autenticarse entre sÃ­**.
Existen tres enfoques principales:

| Enfoque               | DescripciÃ³n                                         | Ejemplo                      |
| --------------------- | --------------------------------------------------- | ---------------------------- |
| **Token compartido**  | Todos los servicios usan una clave o token interno. | Header `X-Internal-Auth`     |
| **JWT de servicio**   | Cada servicio tiene su propio token firmado.        | Claims tipo `service:orders` |
| **mTLS (mutual TLS)** | Cifrado de doble autenticaciÃ³n entre certificados.  | `client.crt` y `server.crt`  |

---

## ğŸ”„ PropagaciÃ³n de identidad

```mermaid
graph TD
  A[Cliente] -->|JWT| G[API Gateway]
  G -->|JWT reenviado| O[Orders Service]
  O -->|JWT reenviado| P[Payments Service]
  P -->|Valida firma| Auth[(Clave pÃºblica)]
```

El **JWT viaja a lo largo de toda la cadena** para mantener el contexto del usuario.
Cada servicio valida la firma sin necesidad de consultar al Auth Service.

---

## âš ï¸ Buenas prÃ¡cticas

âœ… Usar **HTTPS obligatorio** para todo trÃ¡fico.
âœ… Mantener las **claves privadas fuera del cÃ³digo** (usarlas desde variables de entorno o Secret Manager).
âœ… Establecer **tiempos de expiraciÃ³n cortos** en los tokens.
âœ… Implementar **rotaciÃ³n de claves (key rotation)** periÃ³dica.
âœ… Registrar (log) Ãºnicamente **metadatos seguros**, nunca el token completo.
âœ… Aislar el trÃ¡fico interno con **Service Mesh (Istio, Linkerd)** o **NetworkPolicies**.

---

## ğŸ” RelaciÃ³n con el API Gateway

El Gateway puede asumir parte de la seguridad:

* Validar tokens antes de reenviar las peticiones.
* Rechazar trÃ¡fico no autenticado.
* Agregar o propagar cabeceras JWT.
* Centralizar el CORS, rate limiting y logs.

```mermaid
flowchart LR
  C[Cliente] -->|Bearer Token| G[API Gateway]
  G -->|Valida JWT| A[Auth Service]
  G -->|ReenvÃ­a peticiÃ³n vÃ¡lida| S1[Orders]
  G -->|ReenvÃ­a peticiÃ³n vÃ¡lida| S2[Payments]
```

---

## ğŸ§  AnalogÃ­a docente

> Imagina una empresa donde cada empleado tiene una **tarjeta de acceso digital (JWT)**.
> El **vigilante del edificio (API Gateway)** revisa la tarjeta al entrar,
> pero dentro del edificio cada puerta (microservicio) puede verificarla de nuevo antes de abrir.

---

## ğŸ”š ConclusiÃ³n

La **seguridad distribuida** no consiste solo en proteger endpoints,
sino en diseÃ±ar un sistema donde **la identidad y el permiso viajen con cada solicitud**.

**JWT**, **HTTPS** y **API Gateways** son herramientas clave para lograrlo.
En el siguiente laboratorio (5.4), implementaremos un **Gateway real con validaciÃ³n JWT**
para consolidar estos conceptos de forma prÃ¡ctica.
