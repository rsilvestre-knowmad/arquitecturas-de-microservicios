# 5.3 â€“ ConfiguraciÃ³n y secretos en entornos distribuidos

---

## ğŸ¯ Objetivo

Aprender cÃ³mo **gestionar configuraciones y secretos de forma segura** en sistemas distribuidos,
manteniendo la separaciÃ³n entre **cÃ³digo, entorno y credenciales**.

---

## ğŸ§© Contexto

Cada microservicio necesita **configuraciÃ³n propia**:

* puertos, URIs, claves API, tokens, credenciales de base de datos, etc.

Si todo esto se guarda directamente en el cÃ³digo fuente:
âŒ es difÃ­cil cambiar valores,
âŒ se exponen datos sensibles,
âŒ se rompen despliegues al cambiar de entorno (dev, test, prod).

Por eso se externaliza la configuraciÃ³n mediante **variables de entorno, ficheros o servicios externos**.

---

## âš™ï¸ Tipos de configuraciÃ³n

| Tipo                               | Ejemplo                                | Nivel de sensibilidad |
| ---------------------------------- | -------------------------------------- | --------------------- |
| **ParÃ¡metros de entorno**          | `PORT=5000`, `LOG_LEVEL=debug`         | Bajo                  |
| **ConfiguraciÃ³n de conexiÃ³n**      | `DB_HOST`, `REDIS_URL`                 | Medio                 |
| **Credenciales o tokens**          | `DB_PASSWORD`, `JWT_SECRET`, `API_KEY` | Alto                  |
| **Certificados y claves privadas** | `tls.crt`, `service-account.pem`       | CrÃ­tico               |

---

## ğŸ§  Principios fundamentales

1. **Separar configuraciÃ³n del cÃ³digo.**
2. **No almacenar secretos en repositorios.**
3. **Versionar configuraciÃ³n genÃ©rica, no sensible.**
4. **Usar inyecciÃ³n de variables por entorno.**
5. **Cifrar los valores confidenciales en trÃ¡nsito y reposo.**

---

## ğŸ§± 12-Factor App â€“ ConfiguraciÃ³n por entorno

El principio nÃºmero 3 de las [12-Factor Apps](https://12factor.net/config) establece:

> â€œAlmacena la configuraciÃ³n en el entorno, no en el cÃ³digo.â€

Ejemplo en Node.js:

```js
// index.js
const PORT = process.env.PORT || 3000;
const DB_HOST = process.env.DB_HOST;
const DB_PASSWORD = process.env.DB_PASSWORD;

console.log(`Conectando a ${DB_HOST} con contraseÃ±a ${DB_PASSWORD ? "***" : "(no definida)"}`);
```

Y en ejecuciÃ³n:

```bash
DB_HOST=db.example.com DB_PASSWORD=secreto node index.js
```

---

## ğŸ§­ ConfiguraciÃ³n en Docker

### ğŸ§© Variables en `docker-compose.yml`

```yaml
services:
  orders-service:
    image: node:22
    environment:
      - PORT=3000
      - DB_HOST=db
      - DB_PASSWORD=${ORDERS_DB_PASSWORD}
```

El valor `${ORDERS_DB_PASSWORD}` se carga desde un fichero `.env` local,
nunca se escribe directamente en el YAML.

---

### ğŸ“„ Ejemplo de `.env`

```bash
ORDERS_DB_PASSWORD=S3guro_2025!
PAYMENTS_API_KEY=12345-abcde
```

Y se aÃ±ade **al `.gitignore`** para evitar exponerlo en el repositorio:

```
# Evitar exponer secretos
.env
*.pem
*.crt
```

---

## â˜¸ï¸ ConfiguraciÃ³n en Kubernetes

Kubernetes gestiona la configuraciÃ³n con **ConfigMaps** y **Secrets**.

---

### ğŸ§© ConfigMap â€“ configuraciÃ³n no sensible

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: orders-config
data:
  APP_MODE: "production"
  LOG_LEVEL: "info"
```

---

### ğŸ” Secret â€“ datos sensibles (base64)

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: orders-secrets
type: Opaque
data:
  DB_PASSWORD: c2VndXJvX3Bhc3N3b3Jk # "seguro_password" codificado en base64
```

---

### ğŸ“¦ Usar ConfigMaps y Secrets en un Pod

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: orders-service
spec:
  replicas: 1
  template:
    spec:
      containers:
        - name: orders
          image: orders:latest
          envFrom:
            - configMapRef:
                name: orders-config
            - secretRef:
                name: orders-secrets
```

Kubernetes inyecta las claves como variables de entorno dentro del contenedor.

---

## ğŸ§  Estrategias avanzadas

| Estrategia                      | DescripciÃ³n                                   | Ejemplo de uso                        |
| ------------------------------- | --------------------------------------------- | ------------------------------------- |
| **Vault (HashiCorp Vault)**     | Servicio centralizado de gestiÃ³n de secretos. | Cifrado dinÃ¡mico de claves y tokens.  |
| **AWS Secrets Manager**         | Almacena y rota secretos automÃ¡ticamente.     | Credenciales de RDS o API Keys.       |
| **Parameter Store (SSM)**       | ConfiguraciÃ³n jerÃ¡rquica gestionada por AWS.  | Variables `/prod/orders/db/password`. |
| **Sealed Secrets (Kubernetes)** | Cifra los Secrets directamente en YAML.       | DevOps seguro con GitOps.             |

---

## ğŸ§© Ejemplo prÃ¡ctico â€“ ConfiguraciÃ³n segura por entorno

Supongamos tres entornos:

| Entorno  | ConfiguraciÃ³n | DescripciÃ³n                                       |
| -------- | ------------- | ------------------------------------------------- |
| **Dev**  | `.env.dev`    | Valores locales y fijos                           |
| **Test** | `.env.test`   | Variables de staging                              |
| **Prod** | `.env.prod`   | Claves reales cifradas o gestionadas externamente |

Los pipelines CI/CD pueden inyectar los ficheros apropiados al construir la imagen Docker.

---

### ğŸ§° Ejemplo de build CI/CD

```yaml
# .github/workflows/deploy.yml
name: Deploy Orders Service

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Cargar configuraciÃ³n
        run: |
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env

      - name: Construir imagen
        run: docker build -t orders-service:latest .

      - name: Desplegar a Kubernetes
        run: kubectl apply -f k8s/
```

GitHub **inyecta los secretos cifrados** definidos en el repositorio.

---

## ğŸ§© Ejemplo visual: ciclo de vida de la configuraciÃ³n

```mermaid
graph LR
  Dev[.env.dev] -->|Docker build| Img[Docker Image]
  Img -->|Pipeline CI/CD| Sec[Secrets Manager / Vault]
  Sec -->|InyecciÃ³n| K8s[Kubernetes Deployment]
  K8s -->|Variables de entorno| App[Microservicio]
```

---

## âš ï¸ Riesgos y mitigaciones

| Riesgo                          | MitigaciÃ³n                                         |
| ------------------------------- | -------------------------------------------------- |
| Secretos en repositorio         | AÃ±adir `.env` al `.gitignore`.                     |
| Logs con datos sensibles        | Filtrar informaciÃ³n en middleware o logs.          |
| RotaciÃ³n insuficiente de claves | Automatizar rotaciÃ³n periÃ³dica.                    |
| Fuga por imÃ¡genes Docker        | Usar `ARG` o `--build-arg` sin persistir secretos. |
| Permisos excesivos en pods      | Aplicar RBAC y polÃ­ticas mÃ­nimas.                  |

---

## ğŸ§  AnalogÃ­a docente

> Imagina que cada microservicio es un empleado de una empresa.
> La **configuraciÃ³n** es su uniforme (ajustable segÃºn el puesto).
> Los **secretos** son su tarjeta de acceso (personal e intransferible).
> Cada empleado recibe su uniforme y tarjeta al incorporarse, pero nadie las guarda en la carpeta de recursos humanos (el cÃ³digo fuente).

---

## ğŸ”š ConclusiÃ³n

Una buena gestiÃ³n de configuraciÃ³n y secretos:

* Permite desplegar el mismo cÃ³digo en distintos entornos.
* Protege datos sensibles frente a fugas.
* Facilita la automatizaciÃ³n en CI/CD y GitOps.
* Refuerza la seguridad y mantenibilidad global del sistema.

---

ğŸ“˜ En el siguiente laboratorio (**5.4 â€“ PrÃ¡ctica: Gateway y JWT**),
verÃ¡s cÃ³mo aplicar estos principios en la prÃ¡ctica:
el Gateway cargarÃ¡ su configuraciÃ³n desde variables y validarÃ¡ tokens JWT de forma centralizada.