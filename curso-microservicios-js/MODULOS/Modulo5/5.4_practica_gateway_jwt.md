# 5.4 ‚Äì üß™ Laboratorio: API Gateway y Seguridad JWT

---

## üéØ Objetivos

* Implementar un **API Gateway** que centraliza el acceso a varios microservicios.
* Integrar un **Auth Service** que emite tokens JWT.
* Aplicar validaci√≥n y propagaci√≥n del token en el flujo de peticiones.
* Comprobar c√≥mo los servicios internos conf√≠an en el Gateway y en el token firmado.

---

## üß± Estructura del laboratorio

```
LABS/gateway_jwt/
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ gateway/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ auth-service/
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îî‚îÄ‚îÄ orders-service/
    ‚îî‚îÄ‚îÄ index.js
```

---

## ‚öôÔ∏è Paso 1 ‚Äî `docker-compose.yml`

Guarda este archivo como
`LABS/gateway_jwt/docker-compose.yml`

```yaml
version: "3.9"

services:
  gateway:
    image: node:22
    container_name: gateway
    working_dir: /app
    volumes:
      - ./gateway:/app
    command: bash -c "npm install express axios jsonwebtoken && node index.js"
    ports:
      - "4000:4000"
    environment:
      - AUTH_URL=http://auth-service:3005
      - ORDERS_URL=http://orders-service:3006
    depends_on:
      - auth-service
      - orders-service

  auth-service:
    image: node:22
    container_name: auth-service
    working_dir: /app
    volumes:
      - ./auth-service:/app
    command: bash -c "npm install express jsonwebtoken && node index.js"
    ports:
      - "3005:3005"

  orders-service:
    image: node:22
    container_name: orders-service
    working_dir: /app
    volumes:
      - ./orders-service:/app
    command: bash -c "npm install express jsonwebtoken && node index.js"
    ports:
      - "3006:3006"
```

---

## üîê Paso 2 ‚Äî `auth-service/index.js`

Servicio de autenticaci√≥n: genera y valida tokens JWT.

```js
import express from "express";
import jwt from "jsonwebtoken";

const app = express();
app.use(express.json());

const SECRET = "CLAVE_SUPER_SECRETA";

app.post("/login", (req, res) => {
  const { usuario, password } = req.body;
  if (usuario === "admin" && password === "1234") {
    const token = jwt.sign({ sub: usuario, rol: "admin" }, SECRET, { expiresIn: "1h" });
    res.json({ token });
  } else {
    res.status(401).json({ error: "Credenciales inv√°lidas" });
  }
});

app.get("/verify", (req, res) => {
  const header = req.headers.authorization;
  if (!header) return res.status(401).json({ error: "Falta token" });

  try {
    const token = header.split(" ")[1];
    const payload = jwt.verify(token, SECRET);
    res.json(payload);
  } catch {
    res.status(401).json({ error: "Token inv√°lido" });
  }
});

app.listen(3005, () => console.log("üîê Auth Service en puerto 3005"));
```

---

## üì¶ Paso 3 ‚Äî `orders-service/index.js`

Servicio protegido que solo responde a peticiones autenticadas.

```js
import express from "express";
import jwt from "jsonwebtoken";

const app = express();
const SECRET = "CLAVE_SUPER_SECRETA";

function verificarToken(req, res, next) {
  const header = req.headers.authorization;
  if (!header) return res.status(401).json({ error: "Falta token" });
  const token = header.split(" ")[1];

  try {
    req.usuario = jwt.verify(token, SECRET);
    next();
  } catch {
    res.status(401).json({ error: "Token inv√°lido o expirado" });
  }
}

app.get("/pedidos", verificarToken, (req, res) => {
  res.json({
    usuario: req.usuario.sub,
    pedidos: [
      { id: 101, producto: "Port√°til", total: 1200 },
      { id: 102, producto: "Teclado", total: 80 }
    ]
  });
});

app.listen(3006, () => console.log("üì¶ Orders Service en puerto 3006"));
```

---

## üö™ Paso 4 ‚Äî `gateway/index.js`

API Gateway: centraliza peticiones y valida tokens antes de reenviar.

```js
import express from "express";
import axios from "axios";
import jwt from "jsonwebtoken";

const app = express();
app.use(express.json());

const AUTH_URL = process.env.AUTH_URL || "http://auth-service:3005";
const ORDERS_URL = process.env.ORDERS_URL || "http://orders-service:3006";
const SECRET = "CLAVE_SUPER_SECRETA";

// Middleware para logging
app.use((req, res, next) => {
  console.log(`‚û°Ô∏è  ${req.method} ${req.originalUrl}`);
  next();
});

// Ruta de login: se comunica con Auth Service
app.post("/api/login", async (req, res) => {
  try {
    const respuesta = await axios.post(`${AUTH_URL}/login`, req.body);
    res.json(respuesta.data);
  } catch {
    res.status(401).json({ error: "Credenciales inv√°lidas" });
  }
});

// Middleware de validaci√≥n de JWT
app.use(async (req, res, next) => {
  if (req.path.startsWith("/api/login")) return next();

  const header = req.headers.authorization;
  if (!header) return res.status(401).json({ error: "Falta token" });

  const token = header.split(" ")[1];
  try {
    jwt.verify(token, SECRET);
    next();
  } catch {
    res.status(401).json({ error: "Token inv√°lido" });
  }
});

// Ruteo hacia Orders Service
app.get("/api/pedidos", async (req, res) => {
  try {
    const respuesta = await axios.get(`${ORDERS_URL}/pedidos`, {
      headers: { Authorization: req.headers.authorization }
    });
    res.json(respuesta.data);
  } catch {
    res.status(500).json({ error: "Error interno del Gateway" });
  }
});

app.listen(4000, () => console.log("üö™ API Gateway escuchando en puerto 4000"));
```

---

## üß™ Paso 5 ‚Äî Pruebas del flujo

1Ô∏è‚É£ **Levanta el entorno:**

```bash
docker compose up
```

2Ô∏è‚É£ **Obt√©n un token de autenticaci√≥n:**

```bash
curl -X POST http://localhost:4000/api/login \
  -H "Content-Type: application/json" \
  -d '{"usuario":"admin","password":"1234"}'
```

3Ô∏è‚É£ **Guarda el token devuelto:**

```bash
TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6..."
```

4Ô∏è‚É£ **Accede al servicio protegido a trav√©s del Gateway:**

```bash
curl -H "Authorization: Bearer $TOKEN" http://localhost:4000/api/pedidos
```

‚úÖ Respuesta esperada:

```json
{
  "usuario": "admin",
  "pedidos": [
    { "id": 101, "producto": "Port√°til", "total": 1200 },
    { "id": 102, "producto": "Teclado", "total": 80 }
  ]
}
```

---

## üß≠ Flujo visual completo

```mermaid
sequenceDiagram
  participant C as Cliente
  participant G as API Gateway
  participant A as Auth Service
  participant O as Orders Service

  C->>G: POST /api/login
  G->>A: Solicita token
  A-->>G: Devuelve JWT
  G-->>C: Env√≠a JWT al cliente
  C->>G: GET /api/pedidos (Bearer token)
  G->>O: Reenv√≠a petici√≥n con token
  O-->>G: Devuelve pedidos autorizados
  G-->>C: Respuesta final JSON
```

---

## üß† Observa

| Componente         | Funci√≥n                                       |
| ------------------ | --------------------------------------------- |
| **Auth Service**   | Genera y firma el JWT                         |
| **Gateway**        | Punto de entrada, valida tokens y enruta      |
| **Orders Service** | Solo responde si el token es v√°lido           |
| **JWT**            | Propaga identidad del usuario entre servicios |

---

## ‚ö†Ô∏è Buenas pr√°cticas aplicadas

‚úÖ Uso de variables de entorno (`AUTH_URL`, `ORDERS_URL`).
‚úÖ Validaci√≥n y propagaci√≥n de tokens en cada capa.
‚úÖ Separaci√≥n clara de responsabilidades (Auth, Gateway, Service).
‚úÖ Comunicaci√≥n interna por red Docker (`auth-service`, `orders-service`).

---

## üß© Extensiones posibles

* A√±adir un **Payments Service** protegido.
* Implementar **roles** (`rol: admin`) y control de acceso granular.
* Integrar **HTTPS** con certificados autocontenidos.
* A√±adir **logging centralizado** o m√©tricas Prometheus.

---

## üîö Conclusi√≥n

Este laboratorio cierra el m√≥dulo 5 demostrando:

* c√≥mo un **API Gateway** controla la seguridad y ruteo,
* c√≥mo los **tokens JWT** viajan entre microservicios,
* y c√≥mo se garantiza un acceso seguro, extensible y trazable.